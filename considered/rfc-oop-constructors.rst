- Feature Name: Standard OOP model
- Start Date: May 5th 2020
- RFC PR:
- RFC Issue:

Summary
=======

Motivation
==========

Guide-level explanation
=======================

Constructors
------------

Constructors are available to both class record and simple records.

Record, tagged records and class records can declare constructors. A constructor
looks like a primitive that has an in out parameter of the type as first
parameter, and is identified with the "Constructor" aspect of the type.
For example:

.. code-block:: ada

   package P is
      type T1 is tagged null record
      with Constructor => Constr;

      procedure Constr (Self : in out T1);
      procedure Constr (Self : in out T1; Some_Value : Integer);

      type T2 is null record with Constructor => Constr;

      procedure Constr (Self : in out T2; Some_Value : Integer);
   end P;

Once a constructor name is chosen with the "Constructor" aspect, all primitives
declared for this type with the constructor name are considered constructor, it
is an error to declare a primitive of that type for that name that doesn't
match the expected profile. Constructors cannot be called directly, it is an
error to refer to that constructor through a call or aspect.

Every type can decide on different constructor names, children can have
different names than parent (coding style may impose nomenclatura here). For
example:

.. code-block:: ada

   package P is
      type Root is tagged null record
      with Constructor => Root_Constr;

      procedure Root_Constr (Self : in out T1);
      procedure Root_Constr (Self : in out T1; Some_Value : Integer);

      type Child is new Root with null record with Constructor => Child_Constr;

      procedure Child_Constr (Self : in out T2; Some_Value : Integer);
   end P;

As soon as a constructor exist, an objects cannot be created without calling one
of the available constructors, omitting the self parameter. This call is made on
the object creation, using the type followed by 'Make and the
constructor parameters. When preceded by a `new` operator, it creates an
object on the heap. E.g:

.. code-block:: ada

   V : T1; -- OK, parameterless constructor
   V2 : T1 := T1'Make(42); -- OK, 1 parameter constructor

   type T1_Ref is acecss all T1'Class;

   V3 : T1_Ref := new T1;
   V4 : T1_Ref := new T1'Make(42);
   V5 : T2; -- NOT OK, there's no parameterless constructor

In the case of objects containing other objects, innermost objects constructors
are called first, before their containing object.

The `'Make'` function is automatically generated by the compilers. It has
the same parameters, default values and default expressions as the constructor
it calls, with the exception of the first parameter. T'Make is not intrinsic,
it has the same convension as a function of the same profile, and can be used
e.g. as a generic parameter or through a access to subprogram.

Note that constructors will be "scoped" in a future extension of the RFC, but
the scoping notation isn't strictly necessary to implement initial semantics:

.. code-block:: ada

   package P is
      type T1 is tagged record
         procedure T1'Constructor (Self : in out T1);
         procedure T1'Constructor (Self : in out T1; Some_Value : Integer);
      end record;


      type T2 is record
         procedure T2'Constructor (Self : in out T2; Some_Value : Integer);
      end record;
   end P;

Constructor as a Function
-------------------------

Constructors can be used in places where a function taking the same parameters
and returning a definite view of the type is expected, in particular as a value
for a generic parameter or an access-to-subprogram. For example:

.. code-block:: ada

   generic
      type T (<>) is tagged record;

      with function F (V : Integer) return T;
   package G is

   end;

   package P is
      type T1 is tagged null record with Constructor => Constr;

      procedure Constr (Self : in out T1);
      procedure Constr (Self : in out T1; Some_Value : Integer);

      type T2 is null record record with Constructor => Constr;

      procedure Constr (Self : in out T2; Some_Value : Integer);

      type Acc1 is access function (Some_Value : Integer) return T1;

      type Acc2 is access function (Some_Value : Integer) return T2;

      V1 : Acc1 := T1'Make'Access;
      V2 : Acc2 := T2'Make'Access;

      package I1 is new G (T1, T1'Make);
      package I2 is new G (T2, T2'Make);
   end P;

In presence of multiple constructors, the rules of overloading resolution
that apply to subprograms overall would apply here too.

Copy Constructor Overload
-------------------------

Copy constructors overload are available to both class records and simple
records.

A special constructor, a copy constructor, has two parameters: self, and a
reference to an instance of the class. It's called when an object is
initialized from a copy. For example:

.. code-block:: ada

   package P is
      type T1 is tagged null record with Constructor => Constr;

      procedure Constr (Self : in out T1; Source : T1);

If not specified, a default copy constructor is automatically generated.
The implicit copy constructor will call the parent copy constructor, then copy
field by field its additional components, calling component copy constructors if
necessary.

Note that, similar to the parameterless constructor, copy constructor may be
explicitely or implicitely called:

.. code-block:: ada

   V1 : T; -- implicit parameterless constructor call
   V2 : T := V1; -- implicit copy constructor call
   V3 : T := T'Make (V1); -- explicit copy constructor call

Note that by-copy constructor are also called in assignments situations
(following the call to a destructor). e.g.:

.. code-block:: ada

      V1 : T;
      V2 : T;
   begin
      V1 := V2; -- calls destructor on V1, then copy from V2.

A non-limited type always have a by constructor copy available, overloaded or
not.

Super Constructor Call
----------------------

By default, the parent constructor called is the parameterless constructor.
A parametric constructor can be called instead by using the ``Super`` aspect
in the constuctor body, For example:

.. code-block:: ada

   type Root is tagged null record with Constructor => Constr;
   procedure Constr (Self : in out Root; V : Integer);

   type Child is new Root with null record with Constructor => Constr;
   procedure Constr (Self : in out Child);

   procedure Constr (Self : in out Child)
      with Super (42)
   is
   begin
      null;
   end Constr;

Note that the constructor of an abstract type can be called here, for example:

.. code-block:: ada

   type Root is abstract tagged null record with Constructor => Constr;
   procedure Constr (Self : in out Root; V : Integer);

   type Child is new Root with null record with Constructor => Constr;
   procedure Constr (Self : in out Child);


   procedure Constr (Self : in out Child)
      -- Root'Make can be called here to initialize Super
      with Super (42)
   is
   begin
      null;
   end Constr;

When valuating values in the Super aspect, the constructed object does not
exit yet. It is illegal to refer to this parameter in the aspect.

Initialization Lists
--------------------

Constructors may need to initialize / call constructors on two categories of
data:

- fields within that object
- discriminants

The following sections will describe these two cases:

Initialization of Components
^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Initialization of components can be done in two ways:
- Through the default value provided at component declaration.
- Through an ``Initialize`` aspect that can rely on constructor parameters.

If the component is of a type that doesn't have a parameterless constructor, it has
to be initialized by on of these two mechanism.

Here's an example of using ``Initialize`` for such a case:

.. code-block:: ada

   type Some_Type is tagged null record with Constructor => Constr;
   procedure Constr (Self : in out C; Some_Value : Integer);

   type C is tagged record
      F : Some_Type;
   end record with Constructor => Constr;

   procedure Constr (Self : in out C; V : Integer);

   procedure Constr (Self : in out C; V : Integer)
      with Initialize (F => Some_Type'Make (V))
   is
   begin
      null;
   end Constr;


Note that if there is no initialization for components with no default
constructors, the compiler will raise an error:

.. code-block:: ada

   type Some_Type is tagged null record with Constructor => Constr;
   procedure Constr (Self : in out C; Some_Value : Integer);

   type C is tagged record
      F : Some_Type; -- Compilation error, F needs explicit constructor call
   end C;

When a component is mentioned in the initialization list, it overrides its
default initialization. Components that are not in the initialization list are
initialized as described at declaration time. For example:

.. code-block:: ada

   function Print_And_Return (S : String) return Integer is
   begin
      Put_Line (S);

      return 0;
   end;

   type C is tagged record
      A : Integer := Print_And_Return ("A FROM RECORD");
      B : Integer := Print_And_Return ("B FROM RECORD");
   end record with Constructor => Constr;

   procedure Constr (Self : in out C);
   procedure Constr (Self : in out C; S : String);

   procedure Constr (Self : in out C)
   is
   begin
      null;
   end Constr;

   procedure Constr (Self : in out C; S : String)
      with Initialize (A => Print_And_Return (S))
   is
   begin
      null;
   end Constr;

   V1 : C := C'Make; -- Will print A FROM RECORD, B FROM RECORD
   V2 : C := C'Make ("ATERNATE A"); -- Will print ATERNATE A, B FROM RECORD

Note for implementers - the objective of the semantic above is to make
initialization as efficient as possible and to avoid undecessary processing.
Conceptually, a developer would expect to have a specific initialization
procedure generated for each constructor (or maybe, have the initialization
directly expanded in the constructor).

Within an initialization list, the semantic is the same as the one for component
initialization as opposed to component assignment. As a consequence amongst
others, it is possible to initialize limited types:

.. code-block:: ada

   type R is limited record
      A, B : Integer;
   end record;

   type C is limited tagged record
      F : R;
   end record with Constructor => Constr;

   procedure Constr (Self : in out C);

   procedure Constr (Self : in out C)
      with Initialize (F => (1, 2))
   is
   begin
      null;
   end Constr;

The only components that a constructor can initialize in the initialization list
are its own. Parent components are supposed to be initialized by the parent
object. The following for example will issue an error:

.. code-block:: ada

   type Root is tagged record
      A, B : Integer;
   end record;

   type Child is new Root with record
      C : R;
   end record with Constructor => Constr;
   procedure Constr (Self : in out Child);

   procedure Constr (Self : in out Child)
      with Initialize (
         A => 1, -- Compilation Error
         B => 2, -- Compilation Error
         C => 3  -- OK
      )
   is
   begin
      null;
   end Constr;

When valuating values in the Initialize aspect, the constructed object does not
exit yet. It is illegal to refer to this parameter in the aspect. The following
is illegal:

.. code-block:: ada

   type Root is record
      A, B : Integer;
   end record with Constructor => Constr;

   procedure Constr (Self : in out Root)
      with Initialize (
         A => 1, -- OK
         B => Self.A -- Compilation Error
      )
   is
   begin
      null;
   end Constr;


Valuation of Discriminants
^^^^^^^^^^^^^^^^^^^^^^^^^^

In the presence of constructors, discriminants can no longer be set by the code
creating the object, but rather the constructor itself. Here's an example
of legal and illegal code:

.. code-block:: Ada

   package P is
      type T1 (L : Integer) is tagged record
         X : Some_Array (1 .. L);
      end record;

      type T2 (L : Integer) is tagged record
         X : Some_Array (0 .. L);
      end record with Constructor => Constr;
      procedure Constr (Self : in out T2);

      V1 : T1 (10); -- legal
      V2 : T2 (10); -- compilation error
   end P;

Discriminant value need to be set by the constructor as part of the
initialization list. For example:

.. code-block:: Ada

   package P is
      type T2 (L : Integer) is tagged record
         X : Some_Array (0 .. L);
      end record with Constructor => Constr;
      procedure Constr (Self : in out T2; Size : Integer);

      procedure Constr (Self : in out T2; Size : Integer)
         with Initialize (L => Size - 1)
      is
      begin
         null;
      end Constr;

      V2 : T2 := T2'Make (10);
   end P;

As for fields, only the discriminants of the current type can be initialized by
the initialization list, not the parents. In addition, in the presence of
constructors, the parent type discriminants are not set. For example:

.. code-block:: ada

   type Root (V : Integer) is tagged null record with Constructor => Constr;
   procedure Constr (Self : in out Child);

   -- note that we're not specifying Root discriminant as Root has a constructor
   type Child is new Root with null record with Constructor => Constr;
   procedure Constr (Self : in out Child);

Here's a full example demonstrating both a regular use of discriminant and a use
with the new notation:

.. code-block:: ada

   package P is

      type Reg_Root (L_Root : Integer) is tagged record
         V : String (1 .. L_Root);
      end record;

      type Reg_Child (L_Child_1, L_Child_2 : Integer) is new Reg_Root (L_Child_1) with record
         W : String (1 .. L_Child_2);
      end record;

      type New_Root (L_Root : Integer) is tagged record
         V : String (1 .. L_Root);
      end record with Constructor => Constr;

      procedure Constr (Self : in out New_Root; L : Integer);

      type New_Child (L_Child_2 : Integer) is new New_Root with record
         W : String (1 .. L_Child_2);
      end record with Constructor => Constr;
      procedure Constr (Self : in out New_Child; L1, L2 : Integer);

  end P;

  package body P is

   procedure Constr (Self : in out New_Root; L : Integer)
      with Initializes (L_Root => L)
   is
   begin
      null;
   end;

   procedure Constr (Self : in out New_Child; L1, L2 : Integer)
      with Super (L1), Initializes (L_Child_2 => L2)
   is
   begin
      null;
   end;

 end P;

Note that there are two significant differences between the "regular" types and
types that have constructors:
- the parent discriminant is not set at derivation anymore, but through the
call to the super constructor
- the child type does not need to declare additional discriminant anymore just
for the purpose of setting the parent ones.

Subtyping and Discriminants
^^^^^^^^^^^^^^^^^^^^^^^^^^^

When a type is built by constructor, it is not possible to provide the value
of a discriminant other than by valuating it in a constructor. However, it
remains possible to constrain a subtype to be of a certain discriminant type.

For simple record types, this is done either by creating a subtype or by
providing a distriminant constrain at variable or component declaration. This
cannot however be used to create a value. For exmample:

.. code-block:: ada

   type Bla (V : Boolean) is record
      case V is
         when True =>
            A : Integer;
         when False =>
            B, C : Integer;
      end case;
   end record with Constructor => Constr;

   procedure Constr (Self : in out Bla; Val : Boolean)
      with Initialize (V => Val);
   is
      null;
   end Constr;

   V1 : Bla := V'Make (True); -- OK, that's what we want
   V2 : Bla (True); -- NOK, this needs an explicit discriminant check
   V3 : Bla (True) := V'Make (True); -- OK, that's what we want
   V3 : Bla (False) := V'Make (True); -- OK, but will raise an exception at run-time

such subtyping can also be used for components:

.. code-block:: ada

      type Arr1 is array (Integer range <>) of Bla; -- illegal
      type Arr2 is array (Integer range <>) of Bla (True); -- legal

      V2a : Arr2; -- Illegal, no default constructor
      V2b : Arr2 := (others => Bla'Make (True)); -- Legal

      type R is record
         V1 : Bla;	 -- was already illegal
         V2 : Bla (True); -- legal, needs to be valuated by the constructor
      end record;

In this version of the proposal, discriminant subtyping is only legal for
non-tagged types. Considerations around type types are described in the future
possibilities section.

Constructors and Type Predicates
--------------------------------

Type predicates are meant to check the consistency of a type. In the context
of a type that has constructor, the consistency is expected to be true when
exiting the constructor. In particular, the initializion list is not expected
to create a predicate-valid type - predicates will only be checked after the
constructor has been processed.

Constructors Presence Guarantees
--------------------------------

Constructors are not inherited. This means that a constructor for a given class
may not exist for its child.

By default, a class provide a parameterless constructor, on top of the copy
constructor. This parameterless constructor is removed as soon as explicit
constructors are provided. For example:

.. code-block:: ada

   type T1 is tagged record

   end record;

   type T2 is tagged null record with Constructor => Constr;
   procedure Constr (Self : in out T1, X : Integer);

   type T3 is new T2 with null record with Constructor => Constr;
   procedure Constr (Self : in out T1, X : Integer, Y : Integer);

   V1 : T1;        -- OK
   V2a : T2;       -- Compilation error, no parameterless constructor is present
   V2b : T2 := T2'Make (5);   -- OK
   V3 : T3 := T3'Make(5);    -- Compilation error, no more constructor with 1 parameter for T3
   V3 : T3 := T3'Make(5, 6); -- OK

Constructors and Generics
-------------------------

A type used an as a actual of a formal generic parameter is expected to have
a parameterless constructor. This is necessary to enable proper derivation and
allocation. For example:

.. code-block:: ada

   generic
      type T is tagged record;
   package G is
      V : T;
   end G;

   package P is

      type T1 is tagged null record;
      procedure T1 (Self : in out T1);

      type T2 is tagged null record;
      procedure T2 (Self : in out T1; V : Integer);

      package G1 is new G (T1); -- Legal
      package G2 is new G (T2); -- Illegal, T2 doesn't have a parameterless constructor

   end P;

The syntax to provide a constructor on a tagged type is similar to a scopeless
constructor - it's a formal procedure of the name of the type, that takes
an in out reference to the type as first parameter:

.. code-block:: ada

   generic
      type T is tagged record with Constructor => Constr;
      with procedure Constr (V : Integer) return T;
   package G is
      V : T := T'Make (55);
   end G;

   package P is

      type T2 is tagged null record with Constructor => Constr;
      procedure Constr (Self : in out T1; V : Integer);

      package G2 is new G (T2, T2'Make); -- Legal

   end P;

Types without parameterless constructors must either have explicit constructors
declared, or be declared as indefinite type (ie they can't be instanciated in
by the generic).

.. code-block:: ada

   generic
      type T (<>) is tagged record;
   package G is
      procedure Proc (V : T)
   end G;

   package P is

      type T1 is tagged null record with Constructor => Constr;
      procedure Constr (Self : in out T1);

      type T2 is tagged null record with Constructor => Constr;
      procedure Constr (Self : in out T1; V : Integer);

      package G1 is new G (T1); -- Legal
      package G2 is new G (T2); -- Legal

   end P;


Removing Constructors from Public View
--------------------------------------

A special syntax is provided to remove the default parameterless constructor
from the public view, without providing any other constructor. The full view of a
type is then responsible to provide constructor (with or without parameters).
Such object can only be created by code that has visibility over the
private section of the package:

.. code-block:: ada

   package P is
      type T1 is null record with Constructor => Constr;
      procedure Constr (Self : in out T1) is abstract;

   private
      procedure Constr (Self : in out T1);
   end P;

Tagged Hierarchy Consistency
----------------------------

A tagged type can be either created by the legacy mechanism, or by a constructor
as soon as such constructor exist. It is possible to extend a "regular" tagged
type by a "by constructor" tagged type, e.g.:

.. code-block:: ada

   type New_Root is tagged record
      null
   end record;

   type New_Child is new New_Root with record
      null;
   end record with Constructor => Constr;

   procedure Constr (Self : in out New_Child; L1, L2 : Integer);

In that case, any child of New_Child has to be a by-constructor type, ie it
while it is possible to extend a "regular" tagged type by a "by constructor"
tagged type, it is not possible to extend a "by constructor" tagged type by
a regular one.

Reference-level explanation
===========================

Rationale and alternatives
==========================

Rationale for Initialization Lists
----------------------------------

Languages like Java or Python do not require initialization lists. However, by
default, class fields are references and initialized by null. In system-level
languages like C++ or Ada, we want to be able to have fields as direct members
of their enclosing records (as opposed to references). However, these tagged records
may themselves have constructors that need parameters, such parameters may
not be known at the time of the description of the record. They should however
be known when the object is created. As a consequence, in Ada (similar to C++),
we introduced the concept of "Initialization List" which allows to provide
values to fields after receiving the constructor parameters.

Why do we have a Constructor as a Procedure and not a Function?
---------------------------------------------------------------

While explicit calls to a constructor are made through a function call `'Make`,
declaring a constructor is done through a procedure declaration, which might
look suprising. The overall rationale is that the constructed object must
be allocated (and sometimes even partially initialized) before any constructor
operation. The discriminants may need to be valuated, the super constructor
must be called. In some cases, the object memory is already allocated (think
of the case of a component with an implicit constructor call).

Having a constructor as a procedure also allows for expansion without undecessary
copies:

.. code-block:: ada

   package Test is

      type Pos_Array is array (Positive range <>) of Positive;

      type T (S : Integer) is tagged record
         Content : Pos_Array (1..S);
      end record with Constructor => Constr;

      procedure Constr (Self : in out T; S : Integer);

      type U (S2 : Integer) is new T with record
         Content_2 : Pos_Array (1..S2);
      end record with Constructor => Constr;

      procedure Constr (Self : in out T);

   end Test;

   package body Test is
      procedure Constr (Self : in out T; S : Integer)
         with Initializes (S => S * 2);
      is
      begin
         Self.Content := (others => 12);
      end Constr;

      procedure Constr (Self : in out U)
         with Initializes (S2 => 12)
              Super (S => 15)
      is
      begin
         Self.Content2 := (others => 18);
      end Constr;

   end Test;

   ------------------
   --  EXPANDS TO  --
   ------------------

   package body Test is

      --  Initialize part of the constructor. Takes in parameter:
      --  Fields to init
      --  Needed values from the constructor
      procedure _T_Initialize (T__S : in out Integer; S : Integer) is
      begin
         T__S := S * 2;
      end _T_Initialize;

      --  Body part of the constructor. Has the same signature as the user defined
      --  constructor.
      procedure _T_Constructor_Body (Self : in out T; S : Integer) is
      begin
         Self.Content := (others => 12);
      end _T_Constructor_Body;

      function T'Make (S : Integer) return T is
         --  Evaluation of `Initializes` expressions
         T__S : Integer;

      begin
         _T_Initialize (T__S, S);

         declare
            Ret : T (T__S);
         begin
            _T_Constructor_Body (Ret, S);
            return Ret;
         end;

      end T;

      procedure _U_Initialize (U__S2 : in out Integer) is
      begin
         U__S2 := 12;
      end _U_Initialize;

      procedure _U_Constructor_Body (Self : in out U) is
         T__S : Integer;
         U__S2 : Integer;
      begin
         _T_Initialize (T__S, 15);
         _U_Initialize (U__S2, 12);

         declare
            Ret : U (T__S, U__S2);
         begin
            _T_Constructor_Body (T (Ret), S);
            _U_Constructor_Body (Ret);
            return Ret;
         end;
      end _U_Constructor_Body;

   end Test;

Drawbacks
=========

Prior art
=========

Unresolved questions
====================

Future possibilities
====================

Record with Indefinite Fields
-----------------------------

With initialization lists, it becomes possible to envision record with
indefinite fields that are initialized at object creation. This is already
somewhat the case as types without parameterless constructors can already be
initialized by an initialization list and behave like indefinite types in
generics. We could consider allowing:

.. code-block:: Ada

   package P is
      type T1 (<>) is tagged record -- T1 is indefinite
	      X : String;
      end record with Constructor => Constr;
      procedure Constr (Val : String);

      procedure Constr (Val : String)
         with Initialize (X => Val);
      begin
         null;
      end Constr;
   end P;

This could make such constructions easier to write than when they rely on a
discriminant value.

Subtyping with specific discriminants and tagged types
------------------------------------------------------

Consider the following hierarchy:

.. code-block:: Ada

   type Root (D : Boolean) is tagged record
      case D is
         when True =>
            A : Integer;
         when False =>
            B : Integer;
      end case;
   end record with Constructor => Constr;

   procedure Constr (Self : in out Bla; C : Boolean)
      with Initialize (D => C);
   is
      null;
   end Constr;

   type Child is new Root with null record with Constructor => Constr;

   procedure Constr (Self : in out Bla; C : Boolean)
      with Super (C);
   is
      null;
   end Constr;

Child does not have any discrimininant. Root discriminant is set by its own
constructor. There is currently no syntax allowing to subtype Child and provide
a constrain to its discriminant.

An extension of the simple record syntax would be to be able to allow to refer
to parent discriminants in the constraint of a child type, so that one could
write:

.. code-block:: Ada

   V : Child (D => True) := Child'Make (True); -- We can constrain Date

this would allow to create components of type Child.
