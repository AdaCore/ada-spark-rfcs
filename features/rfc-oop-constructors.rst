- Feature Name: Standard OOP model
- Start Date: May 5th 2020
- RFC PR:
- RFC Issue:

Summary
=======

Motivation
==========

Guide-level explanation
=======================

Constructors
------------

Constructors are available to both tagged and untagged records.

Records and tagged records can declare constructors. A constructor
looks like a primitive that has an in out parameter of the type as first
parameter, and is identified with the "Constructor" attribute of the type.
For example:

.. code-block:: ada

   package P is
      type T1 is tagged null record;

      procedure T1'Constructor (Self : in out T1);
      procedure T1'Constructor (Self : in out T1; Some_Value : Integer);

      type T2 is null record;

      procedure T2'Constructor (Self : in out T2; Some_Value : Integer);
   end P;

As soon as a constructor exist, an objects cannot be created without calling one
of the available constructors, omitting the self parameter. This call is made on
the object creation, using the type followed by 'Make and the
constructor parameters. When preceded by a `new` operator, it creates an
object on the heap. E.g:

.. code-block:: ada

   V : T1; -- OK, parameterless constructor
   V2 : T1 := T1'Make(42); -- OK, 1 parameter constructor

   type T1_Ref is access all T1'Class;

   V3 : T1_Ref := new T1;
   V4 : T1_Ref := new T1'Make(42);
   V5 : T2; -- NOT OK, there's no parameterless constructor

In the case of objects containing other objects, innermost objects constructors
are called first, before their containing object.

The `'Make'` function is automatically generated by the compilers. It has
the same parameters, default values and default expressions as the constructor
it calls, with the exception of the first parameter. T'Make is not intrinsic,
it has the same convention as a function of the same profile, and can be used
e.g. as a generic parameter or through a access to subprogram.

Note that constructors will be "scoped" in a future extension of the RFC, but
the scoping notation isn't strictly necessary to implement initial semantics.

Constructor as a Function
-------------------------

Constructors can be used in places where a function taking the same parameters
and returning a definite view of the type is expected, in particular as a value
for a generic parameter or an access-to-subprogram. For example:

.. code-block:: ada

   generic
      type T (<>) is tagged record;

      with function F (V : Integer) return T;
   package G is

   end;

   package P is
      type T1 is tagged null record;

      procedure T1'Constructor (Self : in out T1);
      procedure T1'Constructor (Self : in out T1; Some_Value : Integer);

      type T2 is null record record;

      procedure T2'Constructor (Self : in out T2; Some_Value : Integer);

      type Acc1 is access function (Some_Value : Integer) return T1;

      type Acc2 is access function (Some_Value : Integer) return T2;

      V1 : Acc1 := T1'Make'Access;
      V2 : Acc2 := T2'Make'Access;

      package I1 is new G (T1, T1'Make);
      package I2 is new G (T2, T2'Make);
   end P;

In presence of multiple constructors, the rules of overloading resolution
that apply to subprograms overall would apply here too.

Copy Constructor Overload
-------------------------

Copy constructors overload are available to both tagged and untagged records.

A special constructor, a copy constructor, has two parameters: self, and a
reference to an instance of the class. It's called when an object is
initialized from a copy. For example:

.. code-block:: ada

   package P is
      type T1 is tagged null record;

      procedure T1'Constructor (Self : in out T1; Source : T1);

If not specified, a default copy constructor is automatically generated.
The implicit copy constructor will call the parent copy constructor, then copy
field by field its additional components, calling component copy constructors if
necessary.

Note that, similar to the parameterless constructor, copy constructor may be
explicitely or implicitely called:

.. code-block:: ada

   V1 : T; -- implicit parameterless constructor call
   V2 : T := V1; -- implicit copy constructor call
   V3 : T := T'Make (V1); -- explicit copy constructor call

Note that by-copy constructor are also called in assignments situations
(following the call to a destructor). e.g.:

.. code-block:: ada

      V1 : T;
      V2 : T;
   begin
      V1 := V2; -- calls destructor on V1, then copy from V2.

A non-limited type always has a by-copy constructor available, overloaded or
not.

Super Constructor Call
----------------------

By default, the parent constructor called is the parameterless constructor.
A parametric constructor can be called instead by using the ``Super`` aspect
in the constuctor body, For example:

.. code-block:: ada

   type Root is tagged null record;
   procedure Root'Constructor (Self : in out Root; V : Integer);

   type Child is new Root with null record;
   procedure Child'Constructor (Self : in out Child);

   procedure Child'Constructor (Self : in out Child)
      with Super => (42)
   is
   begin
      null;
   end Child'Constructor;

Note that the constructor of an abstract type can be called here, for example:

.. code-block:: ada

   type Root is abstract tagged null record;
   procedure Root'Constructor (Self : in out Root; V : Integer);

   type Child is new Root with null record;
   procedure Child'Constructor (Self : in out Child);

   procedure Child'Constructor (Self : in out Child)
      -- Root'Make can be called here to initialize Super
      with Super => (42)
   is
   begin
      null;
   end Child'Constructor;

When valuating values in the Super aspect, the object under construction does
not exit yet. It is illegal to refer to its parameter in the aspect.

Initialization Lists
--------------------

Constructors may need to initialize / call constructors on two categories of
data:

- fields within that object
- discriminants

The following sections will describe these two cases:

Initialization of Components
^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Initialization of components can be done in two ways:
- Through the default value provided at component declaration.
- Through an ``Initialize`` aspect that can rely on constructor parameters.

If the component is of a type that doesn't have a parameterless constructor, it
has to be initialized by one of these two mechanism.

Here's an example of using ``Initialize`` for such a case:

.. code-block:: ada

   type Some_Type is tagged null record;
   procedure Some_Type'Constructor (Self : in out C; Some_Value : Integer);

   type C is tagged record
      F : Some_Type;
   end record;

   procedure C'Constructor (Self : in out C; V : Integer);

   procedure C'Constructor (Self : in out C; V : Integer)
      with Initialize => (F => Some_Type'Make (V))
   is
   begin
      null;
   end C'Constructor;


Note that if there is no initialization for components with no default
constructors, the compiler will raise an error:

.. code-block:: ada

   type Some_Type is tagged null record;
   procedure Some_Type'Constructor (Self : in out C; Some_Value : Integer);

   type C is tagged record
      F : Some_Type; -- Compilation error, F needs explicit constructor call
   end C;

When a component is mentioned in the initialization list, it overrides its
default initialization. Components that are not in the initialization list are
initialized as described at declaration time. For example:

.. code-block:: ada

   function Print_And_Return (S : String) return Integer is
   begin
      Put_Line (S);

      return 0;
   end;

   type C is tagged record
      A : Integer := Print_And_Return ("A FROM RECORD");
      B : Integer := Print_And_Return ("B FROM RECORD");
   end record;

   procedure C'Constructor (Self : in out C);
   procedure C'Constructor (Self : in out C; S : String);

   procedure C'Constructor (Self : in out C)
   is
   begin
      null;
   end C'Constructor;

   procedure C'Constructor (Self : in out C; S : String)
      with Initialize => (A => Print_And_Return (S))
   is
   begin
      null;
   end C'Constructor;

   V1 : C := C'Make; -- Will print A FROM RECORD, B FROM RECORD
   V2 : C := C'Make ("ALTERNATE A"); -- Will print ALTERNATE A, B FROM RECORD

Note for implementers - the objective of the semantic above is to make
initialization as efficient as possible and to avoid undecessary processing.
Conceptually, a developer would expect to have a specific initialization
procedure generated for each constructor (or maybe, have the initialization
directly expanded in the constructor).

Within an initialization list, the semantic is the same as the one for component
initialization as opposed to component assignment. As a consequence amongst
others, it is possible to initialize limited types:

.. code-block:: ada

   type R is limited record
      A, B : Integer;
   end record;

   type C is limited tagged record
      F : R;
   end record;

   procedure C'Constructor (Self : in out C);

   procedure C'Constructor (Self : in out C)
      with Initialize => (F => (1, 2))
   is
   begin
      null;
   end C'Constructor;

The only components that a constructor can initialize in the initialization list
are its own. Parent components are supposed to be initialized by the parent
object. The following for example will issue an error:

.. code-block:: ada

   type Root is tagged record
      A, B : Integer;
   end record;

   type Child is new Root with record
      C : Integer;
   end record;

   procedure Child'Constructor (Self : in out Child);

   procedure Child'Constructor (Self : in out Child)
      with Initialize => (
         A => 1, -- Compilation Error
         B => 2, -- Compilation Error
         C => 3  -- OK
      )
   is
   begin
      null;
   end Child'Constructor;

When valuating values in the Initialize aspect, the object under construction
does not exist yet. It is illegal to refer to this parameter in the aspect.
The following is illegal:

.. code-block:: ada

   type Root is record
      A, B : Integer;
   end record;

   procedure Root'Constructor (Self : in out Root)
      with Initialize => (
         A => 1, -- OK
         B => Self.A -- Compilation Error
      )
   is
   begin
      null;
   end Root'Constructor;


Valuation of Discriminants
^^^^^^^^^^^^^^^^^^^^^^^^^^

In the presence of constructors, discriminants can no longer be set by the code
creating the object, but rather the constructor itself. Here's an example
of legal and illegal code:

.. code-block:: Ada

   package P is
      type T1 (L : Integer) is tagged record
         X : Some_Array (1 .. L);
      end record;

      type T2 (L : Integer) is tagged record
         X : Some_Array (0 .. L);
      end record;

      procedure T2'Constructor (Self : in out T2);

      V1 : T1 (10); -- legal
      V2 : T2 (10); -- compilation error
   end P;

Discriminant value need to be set by the constructor as part of the
initialization list. For example:

.. code-block:: Ada

   package P is
      type T2 (L : Integer) is tagged record
         X : Some_Array (0 .. L);
      end record;

      procedure T2'Constructor (Self : in out T2; Size : Integer);

      procedure T2'Constructor (Self : in out T2; Size : Integer)
         with Initialize => (L => Size - 1)
      is
      begin
         null;
      end T2'Constructor;

      V2 : T2 := T2'Make (10);
   end P;

As for fields, only the discriminants of the current type can be initialized by
the initialization list, not the parents. In addition, in the presence of
constructors, the parent type discriminants are not set. For example:

.. code-block:: ada

   type Root (V : Integer) is tagged null record;

   procedure Root'Constructor (Self : in out Root);

   -- note that we're not specifying Root discriminant as Root has a constructor
   type Child is new Root with null record;

   procedure Child'Constructor (Self : in out Child);

Here's a full example demonstrating both a regular use of discriminant and a use
with the new notation:

.. code-block:: ada

   package P is

      type Reg_Root (L_Root : Integer) is tagged record
         V : String (1 .. L_Root);
      end record;

      type Reg_Child (L_Child_1, L_Child_2 : Integer) is new Reg_Root (L_Child_1) with record
         W : String (1 .. L_Child_2);
      end record;

      type New_Root (L_Root : Integer) is tagged record
         V : String (1 .. L_Root);
      end record;

      procedure New_Root'Constructor (Self : in out New_Root; L : Integer);

      type New_Child (L_Child_2 : Integer) is new New_Root with record
         W : String (1 .. L_Child_2);
      end record;

      procedure New_Child'Constructor (Self : in out New_Child; L1, L2 : Integer);

  end P;

  package body P is

   procedure New_Root'Constructor (Self : in out New_Root; L : Integer)
      with Initialize => (L_Root => L)
   is
   begin
      null;
   end New_Root'Constructor;

   procedure New_Child'Constructor (Self : in out New_Child; L1, L2 : Integer)
      with Super => (L1), Initialize => (L_Child_2 => L2)
   is
   begin
      null;
   end New_Child'Constructor;

 end P;

Note that there are two significant differences between the "regular" types and
types that have constructors:
- the parent discriminant is not set at derivation anymore, but through the
call to the super constructor
- the child type does not need to declare additional discriminant anymore just
for the purpose of setting the parent ones.

With discriminants, you may have situations where components are not available.
In this case, the Initialization list need to only refer to components that are
available for the discriminant provided - a constraint error is to be raised
otherwise. For example:

.. code-block:: ada

   type Bla (V : Boolean) is record
      case V is
         when True =>
            A : Integer;
         when False =>
            B : Integer;
      end case;
   end record;

   procedure Bla'Constructor
      with Initialize => (V => True, B => 10); -- Constraint Error
   is
      null;
   end Bla'Constructor;

This is consistent with discriminants used to constrain arrays (the value of the
array would need to match the constrained component).

Subtyping and Discriminants
^^^^^^^^^^^^^^^^^^^^^^^^^^^

When a type is built by constructor, it is not possible to provide the value
of a discriminant other than by valuating it in a constructor. However, it
remains possible to constrain a subtype to be of a certain discriminant type.

For simple record types, this is done either by creating a subtype or by
providing a distriminant constrain at variable or component declaration. This
cannot however be used to create a value. For exmample:

.. code-block:: ada

   type Bla (V : Boolean) is record
      case V is
         when True =>
            A : Integer;
         when False =>
            B, C : Integer;
      end case;
   end record;

   procedure Bla'Constructor (Self : in out Bla; Val : Boolean)
      with Initialize => (V => Val);
   is
      null;
   end Bla'Constructor;

   V1 : Bla := V'Make (True); -- OK, that's what we want
   V2 : Bla (True); -- NOK, this needs an explicit discriminant check
   V3 : Bla (True) := V'Make (True); -- OK, that's what we want
   V3 : Bla (False) := V'Make (True); -- OK, but will raise an exception at run-time

such subtyping can also be used for components:

.. code-block:: ada

      type Arr1 is array (Integer range <>) of Bla; -- illegal
      type Arr2 is array (Integer range <>) of Bla (True); -- legal

      V2a : Arr2; -- Illegal, no default constructor
      V2b : Arr2 := (others => Bla'Make (True)); -- Legal

      type R is record
         V1 : Bla;	 -- was already illegal
         V2 : Bla (True); -- legal, needs to be valuated by the constructor
      end record;

In this version of the proposal, discriminant subtyping is only legal for
untagged types. Considerations around tagged types are described in the future
possibilities section.

Constructors and Type Predicates
--------------------------------

Type predicates are meant to check the consistency of a type. In the context
of a type that has constructor, the consistency is expected to be true when
exiting the constructor. In particular, the initializion list is not expected
to create a predicate-valid type - predicates will only be checked after the
constructor has been processed.

Constructors Presence Guarantees
--------------------------------

Constructors are not inherited. This means that a constructor for a given class
may not exist for its child.

By default, a class provide a parameterless constructor, on top of the copy
constructor. This parameterless constructor is removed as soon as explicit
constructors are provided. For example:

.. code-block:: ada

   type T1 is tagged record
      null;
   end record;

   type T2 is tagged null record;

   procedure T2'Constructor (Self : in out T1, X : Integer);

   type T3 is new T2 with null record;

   procedure T3'Constructor (Self : in out T1, X : Integer, Y : Integer);

   V1 : T1;        -- OK
   V2a : T2;       -- Compilation error, no parameterless constructor is present
   V2b : T2 := T2'Make (5);   -- OK
   V3 : T3 := T3'Make(5);    -- Compilation error, no more constructor with 1 parameter for T3
   V3 : T3 := T3'Make(5, 6); -- OK

Constructors and Generics
-------------------------

Generic formal constructor follow similar syntax and rules as when actual
constructors are declared. Notably:

- A tagged type, when not provided with any specific indication, is expected
  to have a parameterless and a copy constructor.
- When an explicit constructor is added to the list of generic formal
  constructors, no parameterless constructor is required by the generic formal.
- Requirement on parameterless and by copy constructors can be removed by
  marking them abstract.

As for subprograms, generic formal constructors are introduced with the `with`
reserved word. For example:

.. code-block:: ada

   generic
      type T1 is tagged private;
      --  Needs at least a parameterless and a by-copy constructor,
      --  if T1 is by constructor.

      type T2 is tagged private;
      with T2'Constructor (Self : in out T2; V : Integer);
      --  No parameterless constructor expected, but a by-copy one

      type T3 is tagged private;
      with T3'Constructor (Self : in out T3) is abstract;
      --  No parameterless constructor expected, but a by-copy one

      type T4 is tagged private;
      with T4'Constructor (Self : in out T4) is abstract;
      with T4'Constructor (Self : in out T4; Src : T4) is abstract;
      --  Neither parameterless nor by-copy constructor expected
   package G is
     V11: T1; -- OK, we have parameterless constructor for T1
     V12: T1 := V11; -- OK, we have by-copy constructor for T1

     V21: T2; -- NOK, no parameterless constructor expected for T2
     V22: T2 := V21; -- OK, we have by-copy constructor for T2

     V31: T3; -- NOK, no parameterless constructor expected for T3
     V32: T3 := V31; -- OK, we have by-copy constructor for T3

     V41: T4; -- NOK we don't have parameterless constructor for T4
     V42: T4 := V41; -- NOK we don't have by-copy constructor for T4
   end G;

   package P is

      type R1 is tagged null record;
      procedure R1'Constructor (Self : in out R1);
      procedure R1'Constructor (Self : in out R1; V : Integer);

      type R2 is tagged null record;
      procedure R2'Constructor (Self : in out R2; V : Integer);
      procedure R2'Constructor (Self : in out R2; Src : R2) is abstract;

      package G1 is new G (
         T1 => R1,
         T2 => R1,
         T3 => R1,
         T4 => R1
      );
      --  All of these are OK, T1 provides all the necessary constructors

      package G2 is new G (
         T1 => R2, -- Error, R2 doesn't have parameterless and by-copy constructor
         T2 => R2, -- Error, R2 doesn't have parametric and by-copy constructor
         T3 => R2, -- Error, R2 doesn't have by-copy constructor
         T4 => R2 -- OK, no constructor expected here
      );

   end P;

Note that the notation:

.. code-block:: ada

   generic
      type T1 is tagged private;

Accept both by-constructors and non-by constructor types. However,
by-constructor types would need to provide a parametelress constructor and a
copy constructor to be accepted as formal parameters.

Removing Constructors from Public View
--------------------------------------

A special syntax is provided to remove the default parameterless constructor
from the public view, without providing any other constructor. The full view of
a type is then responsible to provide constructor (with or without parameters).
Such object can only be created by code that has visibility over the
private section of the package:

.. code-block:: ada

   package P is
      type T1 is null record;

      procedure T1'Constructor (Self : in out T1) is abstract;

   private
      procedure T1'Constructor (Self : in out T1);
   end P;

Tagged Hierarchy Consistency
----------------------------

A tagged type can be either created by the legacy mechanism, or by a constructor
as soon as such constructor exist. It is possible to extend a "regular" tagged
type by a "by constructor" tagged type, e.g.:

.. code-block:: ada

   type New_Root is tagged record
      null
   end record;

   type New_Child is new New_Root with record
      null;
   end record;

   procedure New_Child'Constructor (Self : in out New_Child; L1, L2 : Integer);

In that case, any child of New_Child has to be a by-constructor type, i.e.
while it is possible to extend a "regular" tagged type by a "by constructor"
tagged type, it is not possible to extend a "by constructor" tagged type by
a regular one.

Initialization
--------------

In certain situations, it's important to know if an object is considered
initialized. For example, this can clarify wether passing a value of such object
may lead to errors.

An object value in a constructor is considered initialized once the `Super` and
`Initialze` aspects have been computed. Formally, the role of the constructor
is to establish further properties than the initialization.

Reference-level explanation
===========================

Rationale and alternatives
==========================

Rationale for Initialization Lists
----------------------------------

Languages like Java or Python do not require initialization lists. However, by
default, class fields are references and initialized by null. In system-level
languages like C++ or Ada, we want to be able to have fields as direct members
of their enclosing records (as opposed to references). However, these tagged records
may themselves have constructors that need parameters, such parameters may
not be known at the time of the description of the record. They should however
be known when the object is created. As a consequence, in Ada (similar to C++),
we introduced the concept of "Initialization List" which allows to provide
values to fields after receiving the constructor parameters.

Why do we have a Constructor as a Procedure and not a Function?
---------------------------------------------------------------

While explicit calls to a constructor are made through a function call `'Make`,
declaring a constructor is done through a procedure declaration, which might
look suprising. The overall rationale is that the constructed object must
be allocated (and sometimes even partially initialized) before any constructor
operation. The discriminants may need to be valuated, the super constructor
must be called. In some cases, the object memory is already allocated (think
of the case of a component with an implicit constructor call).

Having a constructor as a procedure also allows for expansion without unnecessary
copies:

.. code-block:: ada

   package Test is

      type Pos_Array is array (Positive range <>) of Positive;

      type T (S : Integer) is tagged record
         Content : Pos_Array (1..S);
      end record;

      procedure T'Constructor (Self : in out T; S : Integer);

      type U (S2 : Integer) is new T with record
         Content_2 : Pos_Array (1..S2);
      end record;

      procedure U'Constructor (Self : in out T);

   end Test;

   package body Test is
      procedure T'Constructor (Self : in out T; S : Integer)
         with Initialize => (S => S * 2);
      is
      begin
         Self.Content := (others => 12);
      end T'Constructor;

      procedure U'Constructor (Self : in out U)
         with Initialize => (S2 => 12)
              Super => (S => 15)
      is
      begin
         Self.Content2 := (others => 18);
      end U'Constructor;

   end Test;

   ------------------
   --  EXPANDS TO  --
   ------------------

   package body Test is

      --  Initialize part of the constructor. Takes in parameter:
      --  Fields to init
      --  Needed values from the constructor
      procedure _T_Initialize (T__S : in out Integer; S : Integer) is
      begin
         T__S := S * 2;
      end _T_Initialize;

      --  Body part of the constructor. Has the same signature as the user defined
      --  constructor.
      procedure _T_Constructor_Body (Self : in out T; S : Integer) is
      begin
         Self.Content := (others => 12);
      end _T_Constructor_Body;

      function T'Make (S : Integer) return T is
         --  Evaluation of `Initializes` expressions
         T__S : Integer;

      begin
         _T_Initialize (T__S, S);

         declare
            Ret : T (T__S);
         begin
            _T_Constructor_Body (Ret, S);
            return Ret;
         end;

      end T;

      procedure _U_Initialize (U__S2 : in out Integer) is
      begin
         U__S2 := 12;
      end _U_Initialize;

      procedure _U_Constructor_Body (Self : in out U) is
         T__S : Integer;
         U__S2 : Integer;
      begin
         _T_Initialize (T__S, 15);
         _U_Initialize (U__S2, 12);

         declare
            Ret : U (T__S, U__S2);
         begin
            _T_Constructor_Body (T (Ret), S);
            _U_Constructor_Body (Ret);
            return Ret;
         end;
      end _U_Constructor_Body;

   end Test;


Drawbacks
=========

Prior art
=========

Unresolved questions
====================

Future possibilities
====================

Record with Indefinite Fields
-----------------------------

With initialization lists, it becomes possible to envision record with
indefinite fields that are initialized at object creation. This is already
somewhat the case as types without parameterless constructors can already be
initialized by an initialization list and behave like indefinite types in
generics. We could consider allowing:

.. code-block:: Ada

   package P is
      type T1 (<>) is tagged record -- T1 is indefinite
	      X : String;
      end record;

      procedure T1'Constructor (Self : T1; Val : String)

      procedure T1'Constructor (Self : T1; Val : String)
         with Initialize => (X => Val);
      begin
         null;
      end Constr;
   end P;

This could make such constructions easier to write than when they rely on a
discriminant value.

Subtyping with specific discriminants and tagged types
------------------------------------------------------

Consider the following hierarchy:

.. code-block:: Ada

   type Root (D : Boolean) is tagged record
      case D is
         when True =>
            A : Integer;
         when False =>
            B : Integer;
      end case;
   end record;

   procedure Root'Constructor (Self : in out Bla; C : Boolean)
      with Initialize => (D => C);
   is
      null;
   end Root'Constructor;

   type Child is new Root with null record;

   procedure Child'Constructor (Self : in out Bla; C : Boolean)
      with Super => (C);
   is
      null;
   end Child'Constructor;

Child does not have any discriminant. Root discriminant is set by its own
constructor. There is currently no syntax allowing to subtype Child and provide
a constrain to its discriminant.

An extension of the simple record syntax would be to be able to allow to refer
to parent discriminants in the constraint of a child type, so that one could
write:

.. code-block:: Ada

   V : Child (D => True) := Child'Make (True); -- We can constrain D

this would allow to create components of type Child.
